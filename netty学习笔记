netty学习笔记:
	netty的核心组件
	1 Channel：
		channel是java NIO的一个基本构造，
			它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同
			的I/O操作的程序组件）的开放链接，如读操作和写操作。
	NIO中常见channel值：
		1 FileChannel:用于文件的数据读写
		2 DatagramChannel:用于UDP的数据读写
		3 SocketChannel:用于TCP的数据读写，一般是客户端实现
		4 ServerSocketChannel:允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel，一般是服务器实现
	2 回调
		回调作为一个方法，只想一个已经提供给另外一个方法的引用，使得后者在适当的时候调用前者，是操作完成后通知的
		一种常见方法。
	3 Futrue： javaNIO提供，伪异步方式，get方法会阻塞，直到结果返回。
	netty提供了ChannelFutrue，可以注册监听方式进行异步方式，相对来讲比Futrue更好用。netty本身完全是异步和事件驱动的。
	4 事件和channelHandler
	netty是异步时间驱动的网络模型，通过event触发相应的处理器，来处理相应的事件结果，netty姣好的封装，开发人员只需要编写channelHandler的代码，而不需要
	处理网络请求的字符编解码、epoll模型轮询等操作，大大简化了操作。

	
第三章：
 3.1 channel、EventLoop和channelFuture
  3.1.1 channel 接口
	基本的I/O操作(bind()、connet()、read()和write()) 依赖于底层网络传输所提供的原语。在java网络编程中，其基本构造是class socket。netty的channel接口所
	提供的API，大大降低了直接使用Socket类的复杂性。此外channel还是拥有许多预定义的、专门化实现的广泛类层次结构的根，一下是一个简短的清单：
	1 EmbeddedChannel
	2 LocalServerChannel
	3 NioDatagramChannel
	4 NioSctpChannel
	5 NioSocketChannel
  3.1.2 EventLoop接口
	channel-》将channel注册到eventLoop-》在整个生命周期内都使用eventLoop处理I/O事件
	1 一个eventLoopGroup 包含一个或多个eventLoop
	2 一个eventLoop在它的生命周期内只和一个Thread绑定
	3 所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理
	4 一个channel在它的生命周期内只注册于一个EventLoop
	5 一个EventLoop 可能会被分配给一个或多个Channel
	提出问题： 那对于netty模型而言，一个channel仅能绑定一个eventloop，一个eventlopp只能使用一个thread处理是否高效，当channel注册到eventLoopgroup组后，
	eventLoopgroup怎么分配channel注册到不同的eventLoop上，在性能上怎么领先于java nio的epoll模型？
	答：channel绑定一个eventLoop是为了防止多线程导致channel被读取多次，而每一个eventLoop都相当于一个epoll模型，提高了处理效率
	reactor相当于通过eventLoopgroup 来让多个epool模型处理event，而通过服务器端则是通过两个reactor来处理数据，两个reactor使用
	两个eventLoopGroup，第一个eventloopgroup是为了让新的连接更快的进入subReactor模型中，如果只有一个reactor模型，那么当event
	事件在同一时间触发多个的时候，会导致select时间处理过长，导致连接超时，而通过第一个reactor模型，会将已连接socket放入第二个
	处理读写事件的reactor中，从而使得服务端的处理效率得到提升，并通过设置eventloop，来提高并行度。
  3.1.3 channelFutrue
	netty所有的I/O都是异步的，因此一个操作可能不会立即返回，因此netty提供了channelFuture接口，其addListener()方法注册了一个channelFutrueListener，以便
	在某个操作完成时（无论是否成功）得到通知。
  3.2 channelHandler和channelPipeline
   3.2.1 channelHandler
	netty的主要组件是channelHandler，它充当了所有处理入站和出站数据的应用程序编辑的容器。这个是可行的，因为channelHandler的方法是由网络事件触发的。
	事实上，channelHandler可专门用于几乎任何类型的动作，例如将数据从一种格式转换为另外一种格式，或者在转换的过程中所跑出的异常。
	channelInboundHandler是一个经常使用的经常实现的子接口，这种类型的channelHandler接收入站事件和数据，这些数据随后将会被你的应用程序的业务逻辑所处理。
   3.2.2 channelPipeline
	channelPipeline提供了channelHandler链的容器，并定义了用于该链上传播入站和出站事件流的API。当channel被创建时，它会被自动的分配到它的专属ChannelPipeline
	channelHandler安装到channelPipeline中的过程如下所示：
	1 一个channelInitalizer的实现被注册到了ServerBootstrap 中
	2 当channelInitalizer.initChannel()方法被调用时，ChannelInitializer将在channelPipeline中安装一组自定义的channelHandler
	3 channelInitializer将它自己从channelPipeline中移除。
   3.2.3 更加深入的了解channelHandler
	channelHandler子类：
	channelhandlerAdapter
	channelInboundHandler: simpleChannelInboundHandler<T> 是子类
	channelOutboundHandler
	channelDuplexHandler
   3.2.4 编码器和解码器
   对于网络数据而言，底层都是通过字节数组传递，因此netty底层对数据进行了编解码的封装，对于出站消息而言，需要进行编码，而入站则
   需要解码，netty提供的编解码器都实现了channelOutboundHandler或者channelInboundHandler接口，对于入站消息而言，channelRead（）
   方法/事件已经被重写，从每个channel中读取的消息都会被它预置的解码器提供的decode()方法调用，并将已解码的字节转发给channelpipeline
   中的下一个channelInboundHandler。出站消息则是相反，编码器会将消息转换为字节，并转发给channelOutboundHandler。
   3.2.5 抽象类simpleChannelInboundHandler
   对于需要创建的channelHandler而言，你可以继承子类simpleChannelInboundHandler<T>，其中T为要处理成为的java类，其中最重要的方法
   是channelRead0(channelHandlerContext ,T),如果你指定泛型，则read0回传泛型类，可以直接转化为你需要的java类。
  3.3 引导
	目前netty有两种类型的引导：
	1 是基于客户端： bootstrap，用来连接远程主机和端口，eventloopgroup 只有1个
	2 是基于服务端： serverbootstrap，绑定一个本地端口，eventloopgroup 有两个（也可以只有一个，当只有一个的时候，在当前场景下
	共用一个eventLoopGroup）
	为什么服务器要有两个eventLoopGroup？
	第一个eventLoopGroup： 用来引导客户端的连接，
第四章 传输
 4.1 案例研究：传输迁移
  4.1.1 不通过netty使用的OIO和NIO
  4.1.2 通过netty使用的OIO和NIO
  以上两个小节是为了显示netty如何适配阻塞式网络编程和非阻塞式网络编程，突出netty的方便快捷，因为本身netty的代码没有什么变化
  唯一变化的就是绑定的channel类和group类，一个是阻塞式的实例对象，一个是非阻塞的实例对象。
 4.2 传输API
	netty的传输的核心API是channel，它被用于所有的I/O操作，channel的层次见图 4-1
	channel本身的子类有 serverChannel和AbstractChannel,而channel则会被分配一个channelPipeline和ChannelConfig，其中channelConfig
	是包含了该channel的所有配置设置，并且支持热更新，由于特定的传输可能具有独特的设置，所以它可能会实现一个channelConfig的子
	类型。channel也实现了comparable接口因此，当两个不同的channel返回了相同的散列码，那么AbstractChannel中的compareTo()方法
	的实现将会抛出一个Error。
  此外channelPipeline持有所有将应用入站和出站数据以及事件的ChannelHandler实例，这些ChannelHandler实现了应用程序用于处理状态
  变化以及数据处理的逻辑。
	channelHandler的典型用于包括：
	1 将数据从一种格式转换为另一种格式
	2 提供异常的通知
	3 提供channel变为活动的或者非活动的通知
	4 提供当channel注册到EventLoop或者从EventLoop注销时的通知
	5 提供有关用户自定义事件的通知
	channel本身是一个线程安全的对象，因此你可以通过channel向远程节点写数据时，消息会保证按顺序发送，
  4.3 内置的传输
  netty所提供的传输：
  1 NIO io.netty.channel.socket.nio 使用java.nio.channels 包作为基础---基于选择器的方式
  2 Epoll io.netty.channel.epoll 由JNI驱动epoll()和非阻塞IO。这个传输支持只有在Linux上可用的多种特性，如SO_REUSEPORT比NIO传输更快，而且完全是非阻塞的。
  3 OIO io.netty.channel.socket.oio 使用java.net包作为基础--使用阻塞流
  4 Local io.netty.channel.local 可以在VM内部通过管道进行通信的本地传输
  5 Embedded io.netty.channel.embedded Embedded传输，允许使用ChannelHandler而又不需要一个真正的基于网络的传输。这在测试你的
  channelHandler实现时非常有效。
  
  4.3.1 NIO - 非阻塞I/O 
  jdk1.4被引入，其中最重要的是select选择器，选择器背后的基本概念是充当一个注册表，在那里你的请求在Channel的状态发生变化时得到
  通知，可能的变化如下:
  1 新的channel 已经被接受并且就绪； accept
  2 channel的连接已经完成；connect
  3 channel中已有可供读取的数据； read
  4 channel可用于写数据；writer
  详情见4.3图
  零拷贝（zero copy）： 目前是java nio 和epoll模型才可以使用的特性，是可以高效的将数据从文件系统移动到网络接口，而不需要将
  其从内核状态复制到用户空间，也就是通过directBuffer，堆外缓冲区来进行的。
  4.3.2 Epoll模型
  netty的NIO是基于java提供的异步/非阻塞网络编程的通用抽象虽然保证了Netty在非阻塞API可以在任何平台上是以哦那个，但它也包含了相应
  的限制，因为JDK为了在所有系统上提供相同的功能，必须做出妥协。
  Linux平台在内核版本2.5.44引入了epoll模型，想比于旧的select和poll系统调用具有更好的性能，这个也是Linux上非阻塞网络编程的事实标准
  netty为Linux提供了一组NIO API 模型，它更加一致的方式使用epoll，并且以一种更加轻量的方式使用中断，用法也是非常简单，只需要将NioEventLoopGroup
  修改为EpollEventLoopGroup，将NioServerSocketChannel.class更改为EpollServerSocketChannel.class即可。
  4.3.3 OIO -- 旧的阻塞I/O 
  netty如何实现旧的阻塞模型：
  netty通过使用SO_TIMEOUT标记，它指定了一个I/O操作完成的最大毫秒数，如果操作在这个事件内没有完成，则会抛出socketTimeOut Execption，Netty会捕获
  这个异常并继续处理循环，在EventLoop下一次运行时，它将再次尝试。这也是netty这样异步框架支持OIO的唯一方式。
  4.3.4 用JVM内部通信的Local的传输
  在这个传输中，和服务器channel相关联的SocketAddress并没有绑定物理网络地址，相反，只要有服务器还在运行，它就会被存储到注册表中，并在channel关闭
  时注销，因为这个传输并不接受真正的网络流量，所以它不能和其他的传输实现进行互操作。
  4.3.5 Embedded 传输
  Netty提供了一种额外的API，是的你可以将一组channelHandler作为帮助类嵌入到其他channelHandler中，通过这种方式，你可以扩展一个channelHandler的
  功能，而又不需要修改其内部代码，详细见第九章。
  
  4.4 传输中的用例
  略
  
  第五章 ByteBuf
  ByteBuf的优点：
  1 它可以被用户自定义的缓冲区类型扩展；
  2 通过内置的复合缓冲区类型实现了零拷贝；
  3 容量可以按需增长（类似于JDK的StringBuilder）
  4 在读和写这两种模式不需要使用flip方法
  5 读和写使用了不同的索引
  6 支持方法的链式调用
  7 支持引用计数
  8 支持池化
  5.2 ByteBuf -- netty的数据容器
  5.2.1 它是如何工作的
	
  
  5.3 字节级操作
  5.3.1 随机访问索引
  ByteBuf 的索引是从零开始的：第一个字节的索引是0，最后一个字节的索引总是capacity()-1,而与NIO byteBuffer不同的是，ByteBuf是通过readerIndex和
  writerIndex来确定读写位置的，而bytebuffer因为只通过position一个索引位置确定读写位置，因此每次写完之后都需要调用filp来翻转缓冲区。
  5.3.2 顺序访问索引
  ByteBuf通过readerIndex、writerIndex和capacity将缓冲区分为3个区域，
  1是可丢弃区域，指的是已读取的数据。
  2是可读数据，即writerIndex-readerIndex ，cotent区域
  3可写数据，capacity-writerIndex
  5.3.3 可丢弃字节
  byteBuf支持丢弃已读字节，通过discardReadBytes()方法，可以丢弃并回收空间，这个操作会将content复制到readerIndex前，除非真的需要否则不要这么
  做，当内存十分宝贵的时候。
  5.3.4 可读字节
  ByteBuf可以通过read或者skip跳过当前readerIndex的位置
  当被调用的方式是readBytes(ByteBuf dest); 时那么目标dest的writerIndex也将会增加,因为写入的数据多了，所以writerIndex就会增加。
  5.3.5 可写字节
  可以通过writeBytes 写入数据，如果写操作目标是ByteBuf，那么对应的dest的readerIndex也会增加相应的长度。
  5.3.6索引管理
  byteBuf也可以使用markReaderIndex()、markWriterIndex()、resetWriterIndex、resetReaderIndex来标记readerIndex和WriterIndex来标记和重置ByteBuf的
  readerIndex和writerIndex。也可以使用clear方法将readerIndex和writerIndex都设置为0.但是这个比discardReader轻量的多，不会复制内存。
  5.3.7查找操作
  可以通过indexOf和foreachByte查找对应的byte值
  5.3.8 派生缓冲区
  派生缓冲区为ByteBuf提供了以专门的方式来呈现其内容的视图，此类视图是通过以下方法被创造的：
  1 duplicate();   复制一个
  2 slice();  同上
  3 slice(int , int); 复制一个分片
  4 Unpooled.unmodifiableBuffer();
  5 order(ByteOrder); 排序复制一份
  6 readSlice(int); 读取多少位复制一份，readIndex会改变
  每一个方式都会返回新的ByteBuf，它具有自己的读索引、写索引和标记索引。其内部存储于JDK的ByteBuffer一样也是共享的，因此如果你修改了它的内容，也
  同时修改了其对应的源实例，所以要小心。如果想要复制，请使用copy或者copy（int，int）方法，这个将会拥有独立的数据副本。
  5.3.9 读/写操作
  1 get() 和 set() 从给定索引读/写操作，不会引起索引值发生变化
  2 read()和write() ,从给定的索引开始，并且会根据已经访问的字节数对索引进行调整。
  5.4 ByteBufHolder 接口
  不太理解，是一个支持池化的对象。可以支持Netty的高级特性。
  5.5 ByteBuf分配
  5.5.1 按需分配：ByteBufAllocator 接口
  为了降低分配和释放内存的开销，netty通过了interface ByteBufAllocator实现了(ByteBuf的)池化，它可以用来分配我们所描述过的任意类型的ByteBuf实例，
  使用池化是特定于应用程序的决定，其并不会以任何方式改变ByteBuf API（语义）
  可以通过channel或者channelHandlerContext 获取一个ByteBufAllocator的引用。
  ByteBufAllocator accoc=channel.alloc();
  或者
  ByteBufAllocator accoc=ctx.alloc();
  netty 本身提供了两种ByteBufAllocator 的实现： PooledByteBufAllocator 和UnpooledByteBufAllocator.前者池化了ByteBuf的实例以提高性能并最大限度
  地减少内存碎片。此实现使用了一种称之为jemalloc的已被大量现代操作系统所采用的高效方法来分配内存。后者不池化ByteBuf实例，并且每次它被调用时返
  回一个新的实例。
  5.5.2 unpooled 缓冲区
  见 5-8图
  5.5.3 ByteUtil 类
	提供了操作ByteBuf的静态的辅助方法，这个API是通用的，并且与池化无关，所以这些方法已在分配类外部实现。
	方法最有价值的是hexdump方法，以16进制的表示形式打印ByteBuf的内容。
	equals 用来判断两个ByteBuf实例是否相等。
  5.6 引用计数
  主要是为了追踪某个特定对象的活动引用的数量，一个ReferenceCounted实现的实例通常以活动的引用计数为1开始，只要引用计数大于0，就能保证对象不会被
  释放。当活动实例引用的数量减少到0时，该实例就会被释放。
  
  第六章：channelHandler 和 channelPipeline
  6.1.1 channel的生命周期
  interface channel 定义了一组和channelInboundHandler API密切相关的简单但功能强大的状态模型：
  1 channelUnregistered  channel已经被创建，但是还没被注册到eventLoop中。
  2 channelRegistered channel已经被注册到eventLoop中
  3 channelActive channel处于活动状态（已经连接到它的远程节点）。它现在可以接收和发送数据了
  4 channelInactive channel没有连接到远程节点
  channel的生命周期如下：
  channelRegistered -》channelactive -》 channelInactive -》 channelUnregistered
  当前每一个阶段都会生成相应的事件，这些事件会被转发给channelpipeline 中的channelHandler中，其可以对相应的事件作出响应。
  
  6.1.2 channelHandler 的生命周期
  1 channelAdded 当把channelHandler添加到channelpipleline中被调用
  2 handlerRemoved 当把channelHandler移除到channelpipleline中被调用
  3 exceptionCaught 当处理中产生异常时被调用
  channelAdded-》handlerRemoved-》exceptionCaught
  netty 定义了下面两个重要的channelHandler子接口：
  1 channelInboundHandler--- 处理入站数据以及各种状态的变化
  2 channelOutboundHandler --- 处理出站数据并且运行拦截所有的操作
  
  6.1.3 channelInboundHandler 接口
  见6-3图，显示具有哪些事件触发被调用。
  当某个channelInboundHandler 的实现重写了channelRead方法时，它将负责显式地释放与池化的ByteBuf实例相关的内存。Netty为此提供了ReferenceCountUtil
  .release()释放。 如果没有释放，netty会用warn级别日志消息记录未释放的资源。一个更加简单的方式是通过SimpleChannelInboundHandler，但是问题在于
  如果想要用通过frieUserEvent方法向下传递此对象，会导致报错，需要使用retain将其引用+1.
  
  6.1.4 channelOutboundHandler 接口
   bind （ChannelHandlerContext ，SocketAddress，ChannelPromise）   当请求将channel绑定到本地地址时被调用
   connect（ChannelHandlerContext ，SocketAddress，SocketAddress，ChannelPromise） 当请求将channel连接到远程节点时被调用
   disconnect（ChannelHandlerContext，ChannelPromise） 当请求关闭channel时被调用
   close（ChannelHandlerContext，ChannelPromise） 当请求关闭channel时被调用
   deregister（ChannelHandlerContext，ChannelPromise） 当请求将channel从它的Eventloop注销时被调用
   read（ChannelHandlerContext） 当请求从channel读取更多数据时被调用
   flush（ChannelHandlerContext） 当请求通过channel将入队数据冲刷到远程节点时被调用
  。。。
  详情见 6-4
  
  channelPromise 与 ChannelFutrue channelOutboundHandler 中的大部分方法都需要一个channelPromise参数，以便在操作完成时得到通知。
  channelpromise是channelFutrue的一个子类，其定义了一些可写的方法，如setSuccess（）和setFailure，从而使channelFutrue不可变。
  
  6.1.5 channelHandler 适配器
  netty 提供了两个适配器，是channelInboundHandlerAdapter 和 channelHandlerOutboundAdapter ，两个适配器重写了channelHandler的部分方法，
  可以快速的建立起对应的channelHandler的event方法。具体层次结构见6-2
  
  6.1.6 资源管理
  netty 在channelRead和channelWrite方法处理中，进行的内存监控，当你没有通过release方法释放ByteBuf对象时，netty会产生具体的日志消息提醒。
  netty目前提供了4种检测级别，如6-5所示
  
  如果netty在责任链上想要丢弃消息，并不接受，那么需要通过referenceCountUtil.release() 释放资源，并且在write方法中使用promise.setSuccess通知
  ChannelFutrueListener。read则不需要通知，直接释放就可以了。
  
  
  
  
  
	
记录问题：
1 如何通过channelhandlerContext ctx 写出数据到服务端，而服务端又怎么将数据写出到客户端。
2 写出数据是否可以使用channel或者ctx写出？还是只能用其中一个？


思考的问题
 cookie 记录了session的key值，如果返回到浏览器中，通过复制cookie释放可以复制整个会话的状态？
 如果不会是怎么保证安全性的？
 
	
 
	
	
	
	重点： 
